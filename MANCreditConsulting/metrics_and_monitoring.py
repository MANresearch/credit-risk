# -*- coding: utf-8 -*-
"""MANCredit_Metrics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DPrwiUJVph-uQjLgfOg2mQmXG3InsRiF
"""

# metrics_and_monitoring.py

import pandas as pd
import numpy as np
from sklearn.metrics import precision_recall_curve, auc, roc_curve, roc_auc_score
import matplotlib.pyplot as plt
import seaborn as sns

## --- Métricas de Performance e Discriminação Detalhadas ---

def calculate_ks_gini_ap(y_true, y_pred_proba):
    """
    Calcula o KS Statistic, Gini Coefficient (ou Accuracy Ratio) e Average Precision.

    Args:
        y_true (array-like): Valores verdadeiros da variável alvo (0 ou 1).
        y_pred_proba (array-like): Probabilidades previstas pelo modelo para a classe positiva (1).

    Returns:
        dict: Dicionário contendo 'KS_Statistic', 'Gini_Coefficient', 'Average_Precision'.
    """
    # KS Statistic
    fpr, tpr, thresholds = roc_curve(y_true, y_pred_proba)
    ks_statistic = np.max(np.abs(tpr - fpr))

    # AUC-ROC para Gini
    auc_score = roc_auc_score(y_true, y_pred_proba)
    gini_coefficient = 2 * auc_score - 1

    # Average Precision (AP)
    precision, recall, _ = precision_recall_curve(y_true, y_pred_proba)
    average_precision = auc(recall, precision)

    return {
        'KS_Statistic': ks_statistic,
        'Gini_Coefficient': gini_coefficient,
        'Average_Precision': average_precision
    }

def plot_precision_recall_curve(y_true, y_pred_proba, title="Curva Precision-Recall"):
    """
    Plota a Curva Precision-Recall.

    Args:
        y_true (array-like): Valores verdadeiros da variável alvo (0 ou 1).
        y_pred_proba (array-like): Probabilidades previstas pelo modelo para a classe positiva (1).
        title (str): Título do gráfico.

    Returns:
        matplotlib.figure.Figure: Objeto Figure do Matplotlib.
    """
    precision, recall, _ = precision_recall_curve(y_true, y_pred_proba)
    ap = auc(recall, precision)

    fig, ax = plt.subplots(figsize=(8, 6))
    ax.plot(recall, precision, color='purple', lw=2, label=f'Precision-Recall (AP = {ap:.2f})')
    ax.set_xlabel('Recall (Sensibilidade)')
    ax.set_ylabel('Precisão')
    ax.set_title(title)
    ax.legend(loc="lower left")
    ax.grid(True)
    return fig

## --- Métricas de Monitoramento e Robustez ---

def calculate_psi(expected_dist, actual_dist):
    """
    Calcula o Population Stability Index (PSI).

    Args:
        expected_dist (pd.Series): Distribuição de frequência (ou porcentagem) esperada.
        actual_dist (pd.Series): Distribuição de frequência (ou porcentagem) atual/observada.

    Returns:
        float: Valor do PSI.
    """
    # Ensure both distributions have the same index and are normalized
    expected_dist = expected_dist / expected_dist.sum()
    actual_dist = actual_dist / actual_dist.sum()

    # Add a small epsilon to avoid division by zero
    epsilon = 1e-6
    expected_dist = expected_dist.apply(lambda x: max(x, epsilon))
    actual_dist = actual_dist.apply(lambda x: max(x, epsilon))

    psi = ((actual_dist - expected_dist) * np.log(actual_dist / expected_dist)).sum()
    return psi

def monitor_psi(df, score_column, bins=10):
    """
    Simula o cálculo de PSI para uma coluna de scores ao longo do tempo.
    Em um cenário real, você teria dados de diferentes períodos (cohorts).
    Aqui, criamos uma 'distribuição esperada' do dataset completo e 'distribuições atuais'
    de subconjuntos simulados.

    Args:
        df (pd.DataFrame): DataFrame contendo a coluna de score.
        score_column (str): Nome da coluna com os scores do modelo.
        bins (int): Número de bins para discretizar os scores.

    Returns:
        dict: Dicionário com resultados de PSI simulados.
    """
    # 1. Definir a distribuição 'esperada' (baseada em todo o df)
    # Discretizar a coluna de scores em bins
    df['score_bin'] = pd.cut(df[score_column], bins=bins, duplicates='drop', include_lowest=True, right=False)
    expected_counts = df['score_bin'].value_counts().sort_index()

    # Simular dados de 'períodos' subsequentes
    # Em um caso real, você carregaria dados de outros meses/trimestres
    n_samples = len(df)
    simulated_periods = {}
    for i in range(1, 4): # Simula 3 períodos adicionais
        # Simula uma ligeira mudança na distribuição para mostrar PSI
        if i == 1: # Pequeno shift
            sim_scores = df[score_column] + np.random.normal(0, 0.01, n_samples)
        elif i == 2: # Médio shift
            sim_scores = df[score_column] + np.random.normal(0, 0.05, n_samples)
        else: # Grande shift
            sim_scores = df[score_column] + np.random.normal(0, 0.1, n_samples)

        sim_df = pd.DataFrame({score_column: sim_scores})
        sim_df['score_bin'] = pd.cut(sim_df[score_column], bins=bins, duplicates='drop', include_lowest=True, right=False)
        # Remove the line that was causing the error: sim_df['score_bin'] = sim_df['score_bin'].cat.add_categories('Missing')
        # Remove the line that was causing the error: sim_df['score_bin'] = sim_df['score_bin'].fillna('Missing') # Handle potential new values outside bins
        sim_counts = sim_df['score_bin'].value_counts().sort_index()

        # Alinhar índices para cálculo do PSI, filling missing bins with 0
        all_bins = pd.Index(expected_counts.index.union(sim_counts.index).drop_duplicates().sort_values())
        exp_aligned = expected_counts.reindex(all_bins, fill_value=0)
        sim_aligned = sim_counts.reindex(all_bins, fill_value=0)

        simulated_periods[f'Periodo_{i}'] = calculate_psi(exp_aligned, sim_aligned)

    return simulated_periods

def plot_vintage_analysis(n_vintages=5):
    """
    Simula e plota uma análise de Vintage (Curva de Safra).
    Em um cenário real, você teria dados de diferentes cohorts de empréstimos.

    Args:
        n_vintages (int): Número de vintages (safra) a simular.

    Returns:
        matplotlib.figure.Figure: Objeto Figure do Matplotlib.
    """
    fig, ax = plt.subplots(figsize=(10, 6))
    months_on_book = np.arange(1, 13) # 12 meses de acompanhamento

    for i in range(n_vintages):
        # Simular taxas de default que aumentam com o tempo, mas variam por vintage
        # Vintages mais recentes podem ter performance ligeiramente diferente
        base_default_rate = 0.01 + (i * 0.005) # Vintages mais novas com default um pouco maior
        default_curve = 1 - np.exp(-0.2 * months_on_book) # Curva de default
        vintage_performance = base_default_rate * default_curve * 100 # Em porcentagem

        # Adicionar um pouco de ruído para parecer mais real
        vintage_performance = vintage_performance + np.random.normal(0, 0.5, len(months_on_book))
        vintage_performance = np.maximum(0, vintage_performance) # Não deixar negativo

        ax.plot(months_on_book, vintage_performance, marker='o', linestyle='-', label=f'Vintage {2025-n_vintages+i}')

    ax.set_title('Análise de Vintage (Taxa de Inadimplência Acumulada)')
    ax.set_xlabel('Meses em Aberto')
    ax.set_ylabel('Taxa de Inadimplência Acumulada (%)')
    ax.set_xticks(months_on_book)
    ax.grid(True)
    ax.legend(title='Safra de Concessão', bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    return fig

# Exemplo de uso (for testing locally)
if __name__ == '__main__':
    print("Testando metrics_and_monitoring.py...")
    # Crie dados fictícios para teste
    np.random.seed(42)
    y_true_test = np.random.randint(0, 2, 1000)
    y_pred_proba_test = np.random.rand(1000)

    # Teste de métricas detalhadas
    metrics = calculate_ks_gini_ap(y_true_test, y_pred_proba_test)
    print(f"Métricas calculadas: {metrics}")

    fig_prc = plot_precision_recall_curve(y_true_test, y_pred_proba_test)
    plt.show()

    # Teste de PSI
    df_scores = pd.DataFrame({'scores': np.random.normal(0.5, 0.2, 5000)})
    psi_results = monitor_psi(df_scores, 'scores')
    print(f"Resultados de PSI simulados: {psi_results}")

    # Teste de Vintage
    fig_vintage = plot_vintage_analysis()
    plt.show()